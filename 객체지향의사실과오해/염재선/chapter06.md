# 객체 지도
- 길을 모를 때 보는 지도는 잘 변경되지 않는 구조를 기반으로 만들어져서, 오랜 세월이 지나도 사용할 수 있따.
- 세세한 부분이 변경이 되어도, 구조를 중심으로 만들어졌기에, 이해하기 쉽다.

> 구조는 안정적

## 기능 설계 대 구조 설꼐
- 소프트웨어엔 기능, 구조 두 가지 측면이 존재
- 소프트웨어의 세계에선 요구사항이 자주 바뀜 -> 기능이 자주 바뀜
- 개발자는 **변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓아야한다.**
- 어떻게? -> 지도와 같이 구조를 중심으로!

## 안정적인 구조

### 도메인 모델
- 도메인: 사용자가 프로그램을 사용하는 대상 분야
- 모델: 추상화(단순화)한 것
-> 도메일 모델: 사용자가 프로그램을 사용하는 대상 분야를 추상화한 것

- 도메인 모델 = "멘탈 모델" (사용자가 소프트웨어를 바라보는 모형)
    - 멘탈모델 = (디자인 모델 + 사용자 모델 + 시스템 이미지) 
- 소프트웨어는 사용자가 사용하는 것이기 때문에, 사용자가 바라보는 멘탈모델인 '사용자 모델'과 '시스템 이미지'가 일치해야한다.

### 왜 도메인 모델이 안정적일까?
- 도메인 모델은 세세한 기능이 아닌, 사용자들의 일상에 녹아든 흐름이기 때문에 자주 변경될 가능성이 적다.(이자율이 2퍼 오른게 아니라, 이자란 더 내야하는 금액과 같은 잘 변하지 않는 구조가 도메인 모델)


### 도메인 담는 객체지향
- 객체지향은 도메인 모델을 담을 수있는 거의 유일한 패러다임!
-> 객체지향적으로 설계하면 도메인모델을 그대로 코드로 녹일 수 있다.
- 즉, 객체지향으로 설계하면 사용자들이 바라보는 '도메인 모델'을 코드에 쉽게 녹일수있다.(객체지향으로 코드와 도메인모델 간의 유사함!)

### 불안정한 기능을 담는 도메인 모델
- 사용자들이 바라보는 멘탈모델인 도메인모델은 자주 변경되고 바뀌는 불안정한 기능을 담는다. 안정적인 구조위에 기능을 담으면 변경의 여파가 크지 않기 때무네

## 불안정한 구조

### 유스케이스 모델
- 유스케이스란 "사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한것!" (상호작용, 흐름에 중점을 두자)

## 구조 + 기능 (도메인모델 + 유스케이스 모델)
- 위에서 말한것처럼 안정적인 도메인모델에 유스케이스 모델을 담아야 변경의 여파가 크지 않다.
- 둘을 합치자. 도메인 모델을 만들고 그위에 유스케이스에 대해서, 이 책임은 어떤 객체(도메인)이 수행해야하는지 책임주도설계로 책임을 적절히 할당해가면 된다.(이때, 책임을 하는 객체는 서로 협력하는 모습일 것이다.)

- 객체지향적으로 설계하면 도메인 모델 자체를 코드로 녹이게되고, 코드 <-> 도메인 모델간의 표현적 차이는 줄어들 것이다. 그럼 개발자 입장에서도 도메인 모델(안정적인 구조)를 따르는 코드를 보고 쉽게 이해할 수 있고, 객체간 어떤 메시지를 전달하고 수신하며 책임을 수행하는지 알기 쉬울 것이다.

# 내 생각
- 예전에 동아리 면접 때, 내가 한 프로젝트에 대해 '도메인 모델'을 왜 만들었냐고 물어본 적이 있었다. 나는 그때 김영한 형님이 ERD만들면서 도메인 모델을 만들기에, 아~ 백엔드는 그냥 이렇게 하는구나라고 알고있어서 그냥 그렇게 대답한적이있따. 도메인 모델은 사용자의 멘탈모델을 토대로 만들어져, 안정적인 구조이고 객체지향을 이용해서 코드를 구현하면 이 도메인 모델을 코드로 녹일수 있어서 안정적인 코드가 되겠구나~ 라고 대답했으면 좋았을걸!
- 유스케이스는 도메인 모델 위에서 하나의 시나리오에 대해 객체간 어떤 메시지가 필요한지 생각하고 메시지를 통해 어떤 객체에게 어떤 책임을 할당할지 정하면서 이용하면 되게 좋을거같다. 실제로 '도메인 모델 -> 유스케이스를 통해서 책임주도 설계 -> 결론적으로 객체지향적으로 설계'하는 경험을 하지 못했다. 뭔가 기존에 만들던 익숙한 방법들에 빠져서, 새롭게 생각하려고 하지않았던거 같다. 어떤 프레임워크를 쓰던, 도메인 모델을 생각해가며 책임주도 설계를 해보고 싶다.
- NestJS에서 모듈이 도메인과 같은 기능을 하는거 같다. 그렇다면 네스트는 도메인을 토대로 코드를 구현할수있는 틀이 마련되어있는거라 생각된다. 심지어 모듈간 DI할수있는 프로바이더도 지정해줄수 있기 때문에, 모듈을 하나의 객체로 보면 서로 메시지를 주고받는 관계를 명시적으로 지정해줄 수 있는 구나라는 생각도 든다.